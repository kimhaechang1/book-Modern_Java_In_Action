## JAVA 실행과정

https://steady-snail.tistory.com/67

https://tecoble.techcourse.co.kr/post/2021-07-15-jvm-classloader/

https://steady-coding.tistory.com/593

https://d2.naver.com/helloworld/1230

컴파일이 끝난 `Test.class`를 실행하면 일어나는 일을 정리한다.

크게 나누자면 아래와 같다.

1. `Test`의 `main` 메소드를 실행하려는 초기 시도에서 `Test`클래스가 아직 로드되지 않음을 발견함. 즉, JVM이 현재 이 클래스의 바이너리 코드를 갖고있지 않는다는 것

2. 그래서 JVM은 그러한 바이너리 표현이 있는지 `클래스 로더`를 사용한다. 여기서 로딩에 실패하면 에러를 던진다.

3. 로드된 후, Linking 작업을 수행한다. Linking 작업에는 `검증`, `준비` 그리고 (optional) `해결` 과정이 포함된다.

`검증`은 로드된 `Test`클래스의 표현이 Java 언어와 JVM의 요구사항을 만족하는지 확인한다.

`준비`는 내부적으로 JVM에 의해 사용되어지는 메소드 테이블과 같은 정적 스토리지와 데이터 구조에 대한 할당이 포함된다. 이 때 정적 필드는 기본값으로 초기화 된다.

`해결`은 `Test`내에서 참조하고 있는 클래스나 인터페이스들을 올바르게 참조하고 있는지 확인하는 과정이다.

4. 이제 초기화 작업을 진행한다. 모든 클래스 변수와 클래스의 정적 초기화 블록을 실행한다.

만약 슈퍼 클래스가 있다면 재귀적으로 슈퍼클래스를 먼저 초기화 해야 한다.

5. 초기화가 끝난 후 `main` 메소드를 실행시킨다.

## 클래스 로더 와 로딩단계

자바는 동적 로드로서 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다.

이 동적 로드를 담당하는 부분이 JVM 클래스 로더이다.

클래스 로더에는 총 4가지로 분류하며, 각각의 최상위부터 최하위로 계층구조로 되어있다.

1. 부트스트립 클래스로더: JVM을 가동할 때 생성되며, Object 클래스들을 비롯하여 JavaAPI들을 로드한다.

2. 익스텐션 클래스로더: 확장 클래스들을 로드

3. 시스템 클래스로더: 애플리케이션의 클래스들을 로드. 즉, 사용자가 지정한 $CLASSPATH 내의 클래스를 로드한다.

4. 사용자 정의 클래스로더: 애플리케이션 사용자가 직접 코드상에서 생성해서 사용하는 클래스로더

그리고 클래스로더는 다음 4가지 특징을 가진다.

- 계층 구조: 클래스 로더끼리 부모-자식 관계를 이루어 계층구조로 생성된다. 최상위 클래스로더는 부트스트랩 클래스로더이다.

- 위임 모델: 계층 구조를 바탕으로 클래스로더끼리 위임하는 구조로 동작한다. 클래스를 로드할 때 상위 클래스 로더에서 확인하고 결국 없다면 요청받은 클래스로더가 로드한다.

- 가시성 제한: 하위 클래스로더는 상위 클래스로드의 클래스에 접근이 가능하지만, 그 반대는 안된다.

- 언로드 불가: 클래스 로더를 통해 클래스를 로드할 순 있지만, 언로드는 안된다.(프로그래머가 명시적으로 언로드 할 수 없다는 의미)

각 클래스로더는 로드된 클래스들을 보관하는 네임 스페이스(== 클래스 로더 캐시)를 갖는다.

클래스를 로드할 때, 이미 로드된 클래스인지 확인하기 위해서는 네임 스페이스에 보관된 `FQCN`을 기준으로 찾는다.

여기서 `FQCN`이 같더라도 다른 클래스로더가 로드한 클래스면 다른 클래스로 간주한다.

`FQCN`: `Fully Qualified Class Name` 으로서 Java에서는 클래스가 속한 패키지명을 모두 포함한 이름

즉, 클래스 로더가 클래스 로드를 요청받으면, 클래스 로더 캐시, 상위 클래스로더, 자기 자신의 순서로 클래스가 있는지 확인한다.

이전에 로드된적 있는지 클래스 로더 캐시를 확인하고, 클래스로더를 거슬러 올라가며 확인한다.

최상위 클래스로더까지 올라갔는데 못찾았으면, 요청 받은 클래스로더가 파일 시스템에서 클래스를 찾는다.

그렇게 찾은 클래스를 JVM 메모리에 올리기 까지를 `로딩` 단계라고 하고

`링킹` 단계를 거치고 `초기화 단계`를 거친다.

### 링킹

링킹 단계는 검증, 준비, 분석 단계로 나눠져 있으며

검증 단계에서 읽어들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.

준비 단계에서는 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드, 인터페이스 들을 나타내는 데이터 구조를 준비한다.
이 단계에서 정적 필드에 대한 초기화가 이루어진다.

분석 단계에서는 Symbolic Reference 값을 JVM 메모리의 구성요소인 Method Area의 런타임 환경 풀을 통하여 Direct Reference 라는 메모리 주소 값으로 바꾼다.

이말이 무슨말이냐면, 또다른 클래스를 참조해야 할 때, 해당 클래스의 정보가 Method Area에 없을 동안에는 자신의 클래스 상수 풀에는 `FQCN`으로 문자열로 들어가있다.

예를들어 `Main.java`에 `new Test()` 이런 코드를 만났다 라고 하면, `Test`클래스에 대한 메타정보를 찾으려 하는데

여기서 만약 `Test` 클래스가 이전에 참조된 적이 없어서 아직 클래스로더에 의해 로드되지 못했다면

`Main`클래스의 Method Area 내에 `new Test()`에 대한 `Constant Pool`에는 `com.khc.Test` 이런식으로 들어가 있게 된다.

이와 같은 문자열을 심볼릭 참조라고 한다. 그저 상징적인 참조이다.

여기서 참조하는 클래스가 클래스로더에 의해 로드되어 Method Area에 들어오게 된다면,

그때 해당 클래스의 메타정보의 참조값으로 `심볼릭 참조`가 대체된다.

이러한 참조값을 `직접 참조`라고 한다.

이렇게 링킹 단계를 거치고 나면 초기화 단계로 넘어간다.

### 초기화 단계

초기화 단계에서는 클래스 변수들을 초기값으로 초기화 한다.

즉, 정적 초기화 블록 실행 및 클래스 변수들에 초기 할당된 값을 할당한다.

예를들어 아래의 코드가 있으면

```java
public class Main{
    public static int a = 10;
}
```

위와 같은 코드에서 링킹 - 준비 단계로 들어가면 `int a`에 0이 할당된다.

그리고 링킹단계가 끝나고 난 후에 초기 할당된 10이 할당된다.

## 실행 엔진

실행 엔진은 클래스 로더를 통해 RTDA에 배치된 바이트코드를 명령어 단위로 읽어서 실행한다.

가상머신이 이해하는 Byte코드를 기계가 수행하는 형태로 바꿔주는 역할을 수행하며

인터프리터와 JIT 컴파일러 두가지를 혼합하여 사용한다.

### 인터프리터

JVM 안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다.

여기서 매번 같은 메소드가 호출되어도 매순간 해석하고 수행하기에 느리다.

### JIT 컴파일러(Just-In-Time Compiler)

위의 인터프리터의 단점을 보완하기위해 도입된 방식으로

바이트 코드 전체를 컴파일하여 Native Code로 변경하고

그 이후에는 반복해서 해석하는것이 아닌, Native 코드로 직접 실행한다.

여기서 전체를 Native 로 변경하는것은 비용이 크기 때문에 혼합하여 사용한다.

## JVM RTDA (Runtime Data Area)

JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다.

Thread마다 할당되는 영역과 Thread끼리 공유되는 영역으로 나누어서 본다면

Thread 마다는 PC Register, JVM Stack, Native Method Stack으로 이루어져 있고

Thread끼리 공유하는 것은 Heap, Method Area가 있으며 Method Area 내에 Runtime Constant Pool이 있다.

### PC Register

각 스레드마다 존재하고, 현재 수행중인 JVM 명령어의 주소를 갖고 있다.

### JVM 스택

Stack Frame이라는 구조체를 저장하는 스택으로서, JVM은 오직 JVM 스택에 추가하고 제거하는 동작만 수행한다.

Stack Frame은 JVM 내에서 메서드가 수행될 때 마다 하나의 Stack Frame이 생성되어 해당 스레드의 JVM 스택에 추가되고

종료되면 JVM 스택 내에서 Stack Frame이 제거된다.

각 Stack Frame은 LocalVariableArray, Operand Stack, Reference to Constant Pool을 갖고 있다.

- LocalVariableArray: 0번부터 시작하여, 인스턴스 참조값, 파라미터, 메소드 로컬변수 순으로 저장된다.

- Operand Stack: 메소드의 실제 작업공간으로서 지역변수 배열과 데이터를 교환하고 다른 메서드의 호출 결과를 추가하거나 꺼낸다.

- Reference to Constant Pool: Runtime Constant Pool을 참조할때 사용되는 포인터

### Native Method Stack

JNI를 통해 호출되는 다른언어의 코드를 수행하기 위한 스택으로서

언어에 맞게 C 스택이나 C++ 스택이 생성된다.

### 메소드 영역 (Java 7까지는)

https://jaemunbro.medium.com/java-metaspace%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-ac363816d35e

JVM이 읽어들인 바이트코드를 처음 메모리 공간에 올릴때 초기화 대상을 저장히기 위한 메모리공간

해당 클래스의 필드정보, 메소드 정보, 바이트코드, 클래스인지 인터페이스인지 여부 및 슈퍼 클래스 등의 정보를 저장한다.

즉, 메소드 영역에서는 정적 필드와 클래스 구조만을 갖고 있다.

### 메타 스페이스 영역 (Java 8부터)

Java 8부터 JVM에 PermGen이 사라지고 Metaspace가 생겼다.

이때 얘기하는 PermGen은 Method Area를 뜻하는데, Metaspace로 바뀌면서 가장 큰 차이는 Java Heap이 아닌 Native memory 소속으로 바뀌었다.

이로인해

`OutOfMemory: PermGen space` 과 같은 종류의 OOM은 더이상 마주치지 않고

`-Xmx option`에 의해 설정되는 Heap이 더이상 아니게 되었고

최대 크기를 설정하지 않는다면 호스트 운영 시스템의 가용 메모리를 최대한 활용한다. 즉, Host 운영시스템에 의해 제약되는 크기가 된다.

이러한 메타 스페이스는 어떤 살아있는 인스턴스도 없고 어떠한 참조도 없는 상태에서 GC가 일어났을 때 해제된다.

### 런타임 상수 풀

클래스 파일 포멧에서 constant_pool 테이블에 해당하는 영역이다.

JVM내에 메소드 영역에 속해있다.

각 클래스와 인터페이스의 상수 뿐만아니라, 메소드와 필드에 대한 모든 레퍼런스까지 담고 있다.

즉, 상수 자료형을 저장하고 참조하여 중복을 막는 역할을 수행한다.

### Heap

https://devocean.sk.com/blog/techBoardDetail.do?ID=165630&boardType=techBlog

인스턴스 또는 객체를 저장하는 공간

`new` 연산자로 생성되는 클래스와 인스턴스 변수, 배열 타입등의 참조 타입이 저장되는 곳

내부적으로 크게는 Young과 Old로 나눠지고, Young에는 Eden 영역과 서바이버1, 서바이버2 그리고 Old 영역으로 나눠진다.

처음 생성된 객체는 Young의 Eden 영역에 할당된다.

그리고 Minor GC가 발생하면 다른곳에서 참조되지 않는 객체는 메모리에서 제거된다.

Eden에서 제거되지 않는 객체는 서바이버1 또는 서바이버2의 영역에 있다.

즉, Minor GC가 발생하면 서바이버1 -> 서바이버2로 이동하거나 서바이버2 -> 서바이버1 으로 이동한다.

이러한 서바이버 영역사이에서의 이동 중에서도 더이상 참조되지 않는 객체가 발생한다면 메모리에서 제거된다.

MinorGC가 발생하는 동안 계속해서 왔다갔다 살아남은 객체는 Old로 이동되어 진다.

여기서 오랫동안 살아남은 객체 즉, 왔다갔다의 횟수 기준은 age bit로 감별 하며, Minor GC가 발생할때 마다 1씩 증가한다.

설정해둔 한계치를 넘어가게 되면 Old로 이동하게 되고, 미사용으로 식별되는 객체는 Full GC를 통해 제거된다.

여기서 만약 서바이버에 너무많은 객체가 모여들어 영역을 초과한 경우에도

설정해둔 Old 기준이 미치지 않았지만 Old로 옮겨질 수 있다.
